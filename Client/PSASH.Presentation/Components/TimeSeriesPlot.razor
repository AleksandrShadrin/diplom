@using PSASH.Presentation.Models;
@using PSASH.Presentation.Services;

@inject ITimeSeriesTransformer TimeSeriesTransformer
@inject ContextMenuService contextMenuService

@if(values is not null)
{
    @if(TransformType is TransformationType.FFT)
    {
        <RadzenChart ContextMenu="ShowContextMenu">
            <RadzenLineSeries Data="@GetCuttedValues()" ValueProperty="Y" CategoryProperty="X" Title="Преобразованный ряд" LineType="LineType.Solid">
                <RadzenChartTooltipOptions Visible="@ToolTipIsVisible()" />
                <RadzenMarkers MarkerType="MarkerType.None" />
                <RadzenSeriesDataLabels Visible="@false" />
                <RadzenLegend Position="LegendPosition.Bottom" />
            </RadzenLineSeries>
            <RadzenCategoryAxis Padding="20" />
            <RadzenValueAxis Formatter="RoundValue">
                <RadzenGridLines Visible="true" />
                <RadzenAxisTitle Text="Значения" />
            </RadzenValueAxis>
        </RadzenChart>
    } else
    {
        <RadzenChart ContextMenu="ShowContextMenu">
            <RadzenLineSeries Data="@GetCuttedValuesOfSource()" ValueProperty="Y" CategoryProperty="X" Title="Временной ряд" LineType="LineType.Solid">
                <RadzenChartTooltipOptions Visible="@ToolTipIsVisible()" />
                <RadzenMarkers MarkerType="MarkerType.None" />
                <RadzenSeriesDataLabels Visible="@false" />
                <RadzenLegend Position="LegendPosition.Bottom" />
            </RadzenLineSeries>
            <RadzenLineSeries Data="@GetCuttedValues()" ValueProperty="Y" CategoryProperty="X" Title="Сглаженный временной ряд" LineType="LineType.Solid">
                <RadzenChartTooltipOptions Visible="@ToolTipIsVisible()" />
                <RadzenMarkers MarkerType="MarkerType.None" />
                <RadzenSeriesDataLabels Visible="@false" />
                <RadzenLegend Position="LegendPosition.Bottom" />
            </RadzenLineSeries>
            <RadzenCategoryAxis Padding="20" />
            <RadzenValueAxis Formatter="RoundValue">
                <RadzenGridLines Visible="true" />
                <RadzenAxisTitle Text="Значения" />
            </RadzenValueAxis>
        </RadzenChart>
    }
} else
{
    <div class="h-100 d-flex justify-content-center align-items-center">
        <div class="spinner-border" role="status">
        </div>
    </div>
}
@if (TimeSeriesDto.Values.Count > MaxPoints)
{
    <input type="range" class="form-range" min="0" max="@maxShift" step="1" @bind="shift" @bind:event="oninput" />
}

@code {
    [Parameter]
    public TimeSeriesDto TimeSeriesDto { get => timeSeriesDto;
        set
        {
            timeSeriesDto = value;

            sourceValues = timeSeriesDto
                .Values
                .Select((y, idx) => new Point(idx, y))
                .ToArray();

            UpdateValues();
        }
    }

    [Parameter]
    public EventCallback<TimeSeriesDto> TimeSeriesDtoChanged { get; set; }

    [Parameter]
    public int MaxPoints { get; set; } = 350;

    [Parameter]
    public TransformationType TransformType { 
        get => transformType; 
        set
        {
            transformType = value;
            UpdateValues();
        }
    }

    private TransformationType transformType = TransformationType.AVERAGE_MOVING;

    private int k = 3;
    private int shift = 0;
    private int maxShift = 0;

    private Point[] values;
    private Point[] sourceValues;

    private TimeSeriesDto timeSeriesDto = default;

    private string RoundValue(object value)
    {
        var res = (double)value;

        return Double.Round(res, 8).ToString();
    }

    private IEnumerable<Point> GetCuttedValuesOfSource()
    {
        var start = shift * MaxPoints;
        var end = Math.Min((shift + 1) * MaxPoints, sourceValues.Length);

        return sourceValues[start..end];
    }

    private IEnumerable<Point> GetCuttedValues()
    {
        var start = shift * MaxPoints;
        var end = Math.Min((shift + 1) * MaxPoints, values.Length);

        return values[start..end];
    }

    private async Task UpdateValues()
    {
        values = default;

        values = GetValues().ToArray();

        maxShift = values.Length / MaxPoints;

        if (shift > maxShift)
            shift = Math.Max(maxShift - 1, 0);
        StateHasChanged();
    }

    private bool ToolTipIsVisible()
        => TimeSeriesDto is not null && TimeSeriesDto.Values.Count <= 1000;

    private IEnumerable<Point> GetValues()
    {
        if (TimeSeriesDto is not null)
        {
            return TransformValues(TimeSeriesDto.Values)
                .Select((y, idx) => new Point(idx, y));
        }

        return Enumerable.Empty<Point>();
    }

    private List<double> TransformValues(List<double> values)
        => TransformType switch
        {
            TransformationType.FFT => TimeSeriesTransformer
                .FastFourierTransform(values)
                .ToList(),
            TransformationType.AVERAGE_MOVING => TimeSeriesTransformer
                .AverageMoving(values, k)
                .ToList(),
            _ => values
        };

    private void ShowContextMenu(MouseEventArgs args)
    {
        contextMenuService.Open(args, ds =>
            @<RadzenMenu Click="OnContextMenuClick">
                    <RadzenMenuItem Value=TransformationType.AVERAGE_MOVING Text="Скользящая средняя">
                        <div class="row px-4 justify-content-end align-content-center">
                            <RadzenIcon @onclick=OnKSelect Icon="done" class="ms-2 me-auto align-self-center" Style="cursor:pointer;"></RadzenIcon>
                <RadzenNumeric @onkeypress=@OnSelectKKeyPress class="w-75" Min="1" Max="100" @bind-Value="k"></RadzenNumeric>
                        </div>
                    </RadzenMenuItem>
                    <RadzenMenuItem Text="Преобразование Фурье" Value="TransformationType.FFT">
                    </RadzenMenuItem>
        </RadzenMenu>
    );
    }

    private void OnSelectKKeyPress(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            TransformType = TransformationType.AVERAGE_MOVING;
            contextMenuService.Close();
        }
    }

    private void OnKSelect(MouseEventArgs args)
    {
        TransformType = TransformationType.AVERAGE_MOVING;
        contextMenuService.Close();
    }

    private void OnContextMenuClick(MenuItemEventArgs args)
    {
        var type = (TransformationType)args.Value;

        if (type == TransformationType.FFT)
        {
            TransformType = type;
            contextMenuService.Close();
        }
    }

    private record struct Point(double X, double Y);

    public enum TransformationType
    {
        FFT,
        AVERAGE_MOVING,
        SPLINE
    }
}
